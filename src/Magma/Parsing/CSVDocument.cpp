#include "CSVDocument.hpp"

#include <algorithm>
#include <regex>
#include <sstream>

void Magma::CSVDocument::Serialize(std::wostream & stream) const
{
	stream << L"#!CSV " << MajorVersion << L'.' << MinorVersion << L'\n'; // Mark the beginning of the document and its version
	stream << L"# This document was automatically generated by the Magma Engine" << L'\n' << L'\n';

	for (auto& lines : m_data)
	{
		size_t i = 0;
		for (auto& value : lines)
		{
			if (std::find(value.begin(), value.end(), L' ') != value.end() || std::find(value.begin(), value.end(), L',') != value.end())
			{
				stream << L'\"';
				for (auto& c : value)
				{
					if (c == '\"')
						stream << L'\\';
					stream << c;
				}
				stream << L'\"';
			}
			else
				stream << value;
			if (i != lines.size() - 1)
				stream << L',';
			++i;
		}
		stream << L'\n';
	}

	stream << L"#!end" << std::flush; // Mark the end of the document (used when storing multiple documents in a stream)
}

void Magma::CSVDocument::Deserialize(std::wistream & stream)
{
	m_data.clear();

	std::wstring line;

	while (true) // Find header
	{
		if (stream.get() == L'#' && stream.peek() == L'!')
		{
			stream.ignore();
			break;
		}
		if (stream.eof())
			throw FailedToDeserializeException("Failed to deserialize CSV Document, didn't find header");
	}

	// Check version
	{
		int major, minor;

		std::getline(stream, line);
		std::wregex reg(LR"reg(CSV (\d+).(\d+))reg");

		std::wsmatch match;
		if (!std::regex_match(line, match, reg))
			throw FailedToDeserializeException("Failed to deserialize CSV document, invalid header (couldn't get version)");
		major = std::stoi(match.str(1));
		minor = std::stoi(match.str(2));

		if (major != MajorVersion || minor < MinorVersion)
			throw FailedToDeserializeException(("Failed to deserialize CSV document, unsupported major version, current version is " + std::to_string(MajorVersion) + "." + std::to_string(MinorVersion)).c_str());
	}

	// Read data
	m_data = {{}};
	while (std::getline(stream, line))
	{
		if (line.empty() || line[line.find_first_not_of(L' ')] == L'#')
		{
			if (line.size() >= 5 && line.substr(0, 5) == L"#!end")
				break;
			else
				continue;
		}

		std::wstring value;
		bool inQuotes = false;
		std::wstringstream ss(line);

		while (ss.peek() != WEOF)
		{
			auto c = ss.get();
			if (!inQuotes && c == L',')
			{
				m_data.back().push_back(value);
				value = L"";
			}
			else if (c == L'\\')
			{
				value.push_back(ss.get());
			}
			else if (c == L'\"')
			{
				inQuotes = !inQuotes;
			}
			else value.push_back(c);
		}

		if (!value.empty())
		{
			m_data.back().push_back(value);
			value = L"";
		}
		if (!m_data.back().empty())
			m_data.push_back({});
	}
	m_data.pop_back();
}
