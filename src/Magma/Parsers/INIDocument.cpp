#include "INIDocument.hpp"

#include <regex>

const Magma::INIDocument::Entry& Magma::INIDocument::GetEntry(const std::string& region, const std::string& key) const
{
	for (auto& entry : m_data)
		if (entry.region == region && entry.key == key)
			return entry;
	throw KeyNotFoundException(("Couldn't find the entry in this INI document with the key \"" + key + "\"").c_str());
}

void Magma::INIDocument::SetEntry(Entry entry)
{
	for (auto& e : m_data)
		if (e.region == entry.region && e.key == entry.key)
		{
			e.value = entry.value;
			return;
		}
	m_data.push_back(entry);
}

void Magma::INIDocument::RemoveEntry(const std::string & region, const std::string & key)
{
	for (auto it = m_data.begin(); it != m_data.end(); ++it)
		if (it->region == region && it->key == key)
		{
			m_data.erase(it);
			return;
		}
	throw KeyNotFoundException(("Couldn't find the entry in this INI document with the key \"" + key + "\"").c_str());
}

const std::deque<Magma::INIDocument::Entry>& Magma::INIDocument::GetEntries() const
{
	return m_data;
}

std::deque<Magma::INIDocument::Entry> Magma::INIDocument::GetEntries(const std::string & region) const
{
	std::deque<Entry> entries;
	for (auto& entry : m_data)
		if (entry.region == region)
			entries.push_back(entry);
	return entries;
}

std::deque<std::string> Magma::INIDocument::GetRegions() const
{
	std::deque<std::string> regions;
	for (auto& entry : m_data)
		if (std::find(regions.begin(), regions.end(), entry.region) == regions.end())
			regions.push_back(entry.region);
	return regions;
}

void Magma::INIDocument::Clear()
{
	m_data.clear();
}

void Magma::INIDocument::Serialize(std::ostream & stream) const
{
	stream << "?MINI " << MajorVersion << "." << MinorVersion << std::endl;
	stream << "; This document was automatically generated by Magma::INIDocument::Serialize function" << std::endl << std::endl;

	auto regionNames = this->GetRegions();
	for (auto& region : regionNames)
	{
		stream << "[" << region << "]" << std::endl;
		auto entries = this->GetEntries(region);
		for (auto& entry : entries)
			stream << entry.key << "=" << entry.value << std::endl;
	}

	stream << std::endl << "?end" << std::endl;
}

void Magma::INIDocument::Deserialize(std::istream & stream)
{
	m_data.clear();

	std::string line;

	std::string region = "";

	std::regex regionRegex(R"(\[(.*)\])");
	std::regex entryRegex(R"((.*)=(.*))");
	std::regex versionRegex(R"(\?MINI (\d+)\.(\d+))");
	std::smatch match;

	std::getline(stream, line);
	if(!std::regex_search(line, match, versionRegex))
		throw FailedToDeserializeException(("Failed to deserialize MINI document, invalid header \"" + line + "\"").c_str());
	if (MajorVersion != std::stoull(match.str(1)) || MinorVersion < std::stoull(match.str(2)))
		throw FailedToDeserializeException(("Failed to deserialize MINI document, document version " + match.str(1) + "." + match.str(2) + " not supported (current version is " + std::to_string(MajorVersion) + "." + std::to_string(MinorVersion) + ")").c_str());

	while (std::getline(stream, line))
	{
		if (line.empty() || line[0] == ';')
			continue;
		else if (line[0] == '?' && line.size() > 1) // Special function
		{
			if (line.substr(1) == "end")
				break;
			else
				throw ParsingException(("Failed to parse MINI document, unknown special function \"" + line + "\"").c_str());
		}

		if (std::regex_search(line, match, regionRegex))
			region = match.str(1);
		else if (std::regex_search(line, match, entryRegex))
		{
			Entry entry;
			entry.key = match.str(1);
			entry.value = match.str(2);
			entry.region = region;
			this->SetEntry(entry);
		}
	}
}
