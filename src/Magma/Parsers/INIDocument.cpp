#include "INIDocument.hpp"

#include <regex>

const Magma::INIDocument::Entry& Magma::INIDocument::GetEntry(const std::string& section, const std::string& key) const
{
	for (auto& entry : m_data)
		if (entry.section == section && entry.key == key)
			return entry;
	throw ElementNotFoundException(("Couldn't find the entry in this INI document with the key \"" + key + "\"").c_str());
}

void Magma::INIDocument::SetEntry(Entry entry)
{
	for (auto& e : m_data)
		if (e.section == entry.section && e.key == entry.key)
		{
			e.value = entry.value;
			return;
		}
	m_data.push_back(entry);
}

void Magma::INIDocument::RemoveEntry(const std::string & section, const std::string & key)
{
	for (auto it = m_data.begin(); it != m_data.end(); ++it)
		if (it->section == section && it->key == key)
		{
			m_data.erase(it);
			return;
		}
	throw ElementNotFoundException(("Couldn't find the entry in this INI document with the key \"" + key + "\"").c_str());
}

const std::deque<Magma::INIDocument::Entry>& Magma::INIDocument::GetEntries() const
{
	return m_data;
}

std::deque<Magma::INIDocument::Entry> Magma::INIDocument::GetEntries(const std::string & section) const
{
	std::deque<Entry> entries;
	for (auto& entry : m_data)
		if (entry.section == section)
			entries.push_back(entry);
	return entries;
}

std::set<std::string> Magma::INIDocument::GetSections() const
{
	std::set<std::string> sections;
	for (auto& entry : m_data)
		sections.insert(entry.section);
	return sections;
}

void Magma::INIDocument::Clear()
{
	m_data.clear();
}

void Magma::INIDocument::Serialize(std::ostream & stream) const
{
	stream << "?MINI " << MajorVersion << "." << MinorVersion << std::endl;
	stream << "; This document was automatically generated by Magma::INIDocument::Serialize function" << std::endl;

	auto sectionNames = this->GetSections();
	if (sectionNames.find("") != sectionNames.end())
	{
		stream << std::endl;

		auto entries = this->GetEntries("");
		for (auto& entry : entries)
			stream << entry.key << "=" << entry.value << std::endl;
		sectionNames.erase("");
	}

	for (auto& section : sectionNames)
	{
		stream << std::endl;
		stream << "[" << section << "]" << std::endl;
		auto entries = this->GetEntries(section);
		for (auto& entry : entries)
			stream << entry.key << "=" << entry.value << std::endl;
	}

	stream << std::endl << "?end" << std::endl;
}

void Magma::INIDocument::Deserialize(std::istream & stream)
{
	m_data.clear();

	std::string line;

	std::string section = "";

	std::regex sectionRegex(R"(\[(.*)\])");
	std::regex entryRegex(R"((.*)=(.*))");
	std::regex versionRegex(R"(\?MINI (\d+)\.(\d+))");
	std::smatch match;

	std::getline(stream, line);
	if(!std::regex_search(line, match, versionRegex))
		throw FailedToDeserializeException(("Failed to deserialize MINI document, invalid header \"" + line + "\"").c_str());
	if (MajorVersion != std::stoull(match.str(1)) || MinorVersion < std::stoull(match.str(2)))
		throw FailedToDeserializeException(("Failed to deserialize MINI document, document version " + match.str(1) + "." + match.str(2) + " not supported (current version is " + std::to_string(MajorVersion) + "." + std::to_string(MinorVersion) + ")").c_str());

	while (std::getline(stream, line))
	{
		if (line.empty() || line[0] == ';')
			continue;
		else if (line[0] == '?' && line.size() > 1) // Special function
		{
			if (line.substr(1) == "end")
				break;
			else
				throw FailedToDeserializeException(("Failed to parse MINI document, unknown special function \"" + line + "\"").c_str());
		}

		if (std::regex_search(line, match, sectionRegex))
			section = match.str(1);
		else if (std::regex_search(line, match, entryRegex))
		{
			Entry entry;
			entry.key = match.str(1);
			entry.value = match.str(2);
			entry.section = section;
			this->SetEntry(entry);
		}
	}
}
